package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"os/exec"
	"time"
	"strings"

	"github.com/go-vgo/robotgo"
)

var encryptionKey = []byte("Bq!Â§X[{f&>T4bFnUtPo'rY7]9@,%]Di") // MUST be 32 bytes

func printHelp() {
	fmt.Println("Usage: KeePassStarter [command] [args]")
	fmt.Println("Commands:")
	fmt.Println("  decrypt [keePassPath] [databasePath] [encryptedPassword]   Start KeePass and unlock the database")
	fmt.Println("  encrypt [cleartextPassword]                            Encrypt a password")
	fmt.Println("  -h, --help                                             Show this help message")
	fmt.Println("\nExamples:")
	fmt.Println("  KeePassStarter decrypt C:\\Path\\To\\KeePass.exe C:\\Path\\To\\Database.kdbx MyP@ssw0rd")
	fmt.Println("  KeePassStarter encrypt MyP@ssw0rd")
}

func encryptPassword(password string) (string, error) {
	block, err := aes.NewCipher(encryptionKey)
	if err != nil {
		return "", err
	}

	ciphertext := make([]byte, aes.BlockSize+len(password))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], []byte(password))

	return hex.EncodeToString(ciphertext), nil
}

func decryptPassword(encrypted string) (string, error) {
	ciphertext, err := hex.DecodeString(encrypted)
	if err != nil {
		return "", err
	}

	block, err := aes.NewCipher(encryptionKey)
	if err != nil {
		return "", err
	}

	if len(ciphertext) < aes.BlockSize {
		return "", fmt.Errorf("ciphertext too short")
	}

	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)
	stream.XORKeyStream(ciphertext, ciphertext)

	return string(ciphertext), nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Error: Missing command.")
		printHelp()
		return
	}

	command := os.Args[1]

	switch command {
		case "-h", "--help":
			printHelp()
			return

		case "encrypt":
			if len(os.Args) != 3 {
				fmt.Println("Error: Missing password to encrypt.")
				printHelp()
				return
			}
			password := os.Args[2]
			encrypted, err := encryptPassword(password)
			if err != nil {
				fmt.Printf("Error encrypting password: %v\n", err)
				return
			}
			fmt.Printf("Encrypted password: %s\n", encrypted)
			return

		case "decrypt":
			if len(os.Args) != 5 {
				fmt.Println("Error: Missing arguments.")
				printHelp()
				return
			}

			keePassPath := os.Args[2]
			databasePath := os.Args[3]
			encryptedPassword := os.Args[4]

			password, err := decryptPassword(encryptedPassword)
			if err != nil {
				fmt.Printf("Error decrypting password: %v\n", err)
				return
			}

			fmt.Printf("Waiting for 60 seconds to ensure the machine boots up properly.")
			time.Sleep(60 * time.Second)

			cmd := exec.Command(keePassPath, databasePath)
			err = cmd.Start()
			if err != nil {
				fmt.Printf("Error starting KeePass: %v\n", err)
				return
			}

			// Allow time for KeePass to start
			time.Sleep(2 * time.Second)

			// Bring KeePass to the front if it is not active already
			// Do NOT use robotgo.ActiveName("keepass"), its kinda buggy
			// Instead cycle through the windows until KeePass is active
			attempts := 1
			for {
				title := robotgo.GetTitle()
				fmt.Println("Current Title: ", title)
		
				if strings.Contains(strings.ToLower(title), "open database -") {
					// KeePass should now be active
					break
				}
		
				robotgo.KeyDown("alt")
				for i := 0; i < attempts; i++ {
					robotgo.KeyTap("tab")
					time.Sleep(50 * time.Millisecond)
				}
				robotgo.KeyUp("alt")
		
				attempts++

				time.Sleep(500 * time.Millisecond)
			}
		
			// Unlock the database
			robotgo.TypeStr(password)
			time.Sleep(500 * time.Millisecond)
			robotgo.KeyTap("enter")
			time.Sleep(500 * time.Millisecond)

			// Lock the database
			robotgo.KeyDown("ctrl")
			robotgo.KeyTap("l")
			robotgo.KeyUp("ctrl")
			
		default:
			fmt.Println("Error: Unknown command.")
			printHelp()
	}
}
